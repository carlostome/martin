\documentclass[11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{todonotes}
\usepackage{enumitem}  % http://www.ctan.org/pkg/enumitem
\usepackage[noabbrev]{cleveref}
\usepackage{fancyvrb}
\usepackage{unicornsoflove}
\usepackage{hyperref}

 \DefineVerbatimEnvironment
   {code}{Verbatim}
   {} % Add fancy options here if you like.

\author{Carlos Tomé Cortiñas
  \and Fabian Thorand
  \and Ferdinand van Walree
  \and Renate Eilers
  \and  \small{Department of Information and Computing Sciences, Utrecht University}
  }
\title{Stepwise construction of simple Agda programs}
\subtitle{Research Report}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents

\section{Program Construction}

\subsection{Assumptions and Restrictions}

\begin{itemize}
\item fully saturated functions (i.e.\ all parameters are occurring on the left
  hand side of the definition)
\item all types are in \texttt{Set}, the lowest level of the universe hierarchy
\item data constructors don't have function arguments
\end{itemize}

\subsection{Rules of Construction}

\paragraph{Case splitting}

\begin{itemize}
\item given a $n$-ary function $f : (x_1 : T_1) \rightarrow (x_2 : T_2\ x_1)
  \rightarrow \cdots \rightarrow T_{n+1}\ x_1\ \ldots\ x_n $ where the argument
  types can depend on the values of the arguments to their left, where
  $T_i\ x_1\ \ldots\ x_{i-1}$ can be a function type, a data type or
  \texttt{Set}. In the latter case, the arguments passed to $T_i$ do not
  actually matter
\item note that it is only possible to match on data types
\item case splits are only allowed in definition clauses of the following form
  \begin{equation}
    \label{eq:f_def}
    f\ p_1\ \ldots\ p_n = \mathbf{hole}
  \end{equation}
  where $p_1, \ldots, p_n$ denote the argument patterns and \textbf{hole} is a
  metavariable. This means that we can only case split, if the whole right hand
  side consists of a single hole.
\item abstract syntax of patterns
  \begin{equation}
    \begin{array}{rcl}
      x & \in & \mathbf{Var} \\
      p & ::= & x \mid \mathbf{Constr}\ p_1\ \ldots\ p_n
    \end{array}
  \end{equation}
\item a case split can only be applied to (possibly nested) variables in one of
  the patterns, if the type of that variable is a data type (i.e.\ it has been
  introduced by a \texttt{data} declaration)
\item a successful case split on a variable $x$ replaces the current clause with
  one new clause for every data constructor corresponding to the type of $x$,
  replacing the occurrence of $x$ with a new pattern and fresh variables for
  each constructor argument.
  Only constructors whose type can be unified with the type of $x$ are
  considered.
  This is demonstrated in the example below.
  \begin{lstlisting}[mathescape, gobble=4, language = agda]
    data Foo : Nat -> Set where
      Bar : Foo 0
      Baz : forall {n} -> Foo (succ n)

    foo : (n : Nat) -> Foo n -> Nat
    foo zero Bar = {!!}
    foo (succ n) Baz = {!!}
  \end{lstlisting}
  Case splitting on the second argument (after the first argument) in the first clause only introduced the
  \texttt{Bar} constructor, as the type of the \texttt{Baz} constructor does not
  unify with \texttt{Foo 0}.
\item splitting variables can affect other patterns, e.g. by introducing dot
  patterns\footnote{\url{http://agda.readthedocs.io/en/latest/language/function-definitions.html\#dot-patterns}}.
  In the example above, this can be witnessed by first splitting on the second
  argument, resulting in
  
  \begin{lstlisting}[mathescape, gobble=4, language = agda]
    foo : (n : Nat) -> Foo n -> Nat
    foo .0 Bar = {!!}
    foo _ Baz = {!!}
  \end{lstlisting}
  
\end{itemize}

some heuristics to guide case splitting
\begin{itemize}
\item perform case splits in a breadth-first manner, i.e.\ first try split all
  variables on the current level before trying to perform case splitting on the
  variables nested inside constructor patterns.
\item if all $n$ arguments are independent and every data type consists of at
  most $m$ constructors, case splitting all variables on the top-most level
  results in at most $m^n$ clauses.
  In realistic examples making use of Agda's support for dependent types, we
  expect this number to be a lot smaller.
\item sometimes, it might only be possible to split a variable after first
  having split some other arguments before it, although we are not sure (yet)
  for which programs this is the case and whether it will affect our approach.
\item a good guess for the order in which to perform case splitting might be the
  topological sorted dependency graph of the argument types, starting with the
  arguments on which no further arguments depend.
  In the type signature
  
  \begin{lstlisting}[mathescape, gobble=4, language = agda]
    (m n : Nat) -> (p : m == n) -> n == m
  \end{lstlisting}
  a valid topologically sorted sequence would be $m, n, p$, hence we would split
  first on $p$.
  The disadvantage of this approach is that it introduces dot patterns in the
  preceding arguments, where we do not know how to handle them appropriately
\end{itemize}

\paragraph{Refinement}

\begin{itemize}
\item A refinement is the introduction of a (possibly) incomplete term of the
  right type in a hole
\item case splitting is not possible after starting to refine the right hand
  side of a clause. If no solution can be found, backtracking is needed.
\item if a hole requires a function, we can only fill it with a definition in
  scope that has a matching type. For now, we do not support the introduction of
  lambda expressions.
\item a hole that requires a data type can be either refined with a data
  constructor, a variable of the right type, or with function returning a value
  of the required type.
  For constructors and functions, new holes are introduced for every argument.
  If the function is a recursive call, then at least one of the arguments must
  be structurally smaller.
\item search depth must be limited to prevent the search from generating
  infinitely nested data constructors.
\end{itemize}

some heuristics for refinement

\begin{itemize}
\item a variable of a correct type should always be preferred over introducing
  data constructors or function calls, because it clearly leads to the simplest
  solutions
\end{itemize}

\subsection{Combining case split and refinement}

\begin{itemize}
\item every clause of the definition is independent from all others
\item the basic algorithm should always first try to find a solution for the
  right hand side of a clause, and only if that fails, perform another case
  split.
\item we should investigate whether it is possible to retain partial solutions
  between to attempts of solving the same goal, that only differ in some
  additional case splits.
\end{itemize}

\subsection{Introducing Properties}

\begin{itemize}
\item basic properties on some function $f$ should be of the following shape
  \begin{equation}
    \label{eq:prop}
    \forall \vec{x}. f\ t_1\ \ldots\ t_n \equiv t_{n+1}
  \end{equation}
  where $t_1, \ldots, t_{n+1}$ are terms possibly involving some of the
  universally quantified variables.
  This provides simple means for stating relations between the inputs and result
  of a function.
\item investigate whether we can handle universal quantification in properties
\item Before starting the refinement phase, we can check which properties apply
  to the current clause. Then we can use Agda to (partially) normalize the
  property expression, resulting in an expression, that might contain additional
  metavariables. But even these partial results can be used to restrict the set
  of possible solutions to a hole, if the metavariables only occur inside some
  constructors.
\item investigate whether properties can be used for guiding case splits. for
  example, if we consider the property $\forall x. x + 0 \equiv x$, then it
  might be sensible to assume that splitting on the second argument is
  preferred.
\item it seems that universally quantified properties are only helpful during
  the search phase, if the universally quantified arguments are exactly those,
  that are not case-split during the search
\end{itemize}

\subsection{The Strategy}

For a given type signature we use Agda's expressive type system to generate a
model solution. Here, we need to take into account the current partial solution
created by the student, because they might have chosen a different path leading
to the same (or different but also valid) solution.

If no solution can be found starting at the students current partial solution,
then either the path chosen by the student will indeed not lead to a successful
completion of the problem, or it will, but the algorithm is just not able to
find it.

When we have found a model solution, we track back the steps taken by the search
algorithm to provide a strategy that can be used to give hints to the student.
Ideally, if the type signature is strong enough, there is only one valid
solution to an Agda program.

\begin{itemize}
\item on the top level of the strategy, we can interleave the sub-strategies for
  solving individual clauses of a function definition. (they are independent of
  each other)
\item trying to solve a certain clause can produce more clauses when case splits
  are performed
\item when solving a clause, case splits must always be performed before
  refinements
\item the order of refining holes in the current clause generally does not
  matter (i.e.\ it could be interleaved), but in certain cases Agda will only
  accept a refinement for a function argument if another argument is refined
  before
\item the case split strategy is constructed from a valid order of splits that
  lead to a successful completion of the right hand side
\item the refinement strategy is guided by the steps taken by the proof search
\end{itemize}

\bibliographystyle{plain}
\bibliography{literature}

\end{document}
