{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeSynonymInstances  #-}
module Martin.Strategy where

import qualified Agda.Interaction.BasicOps    as B
import qualified Agda.Syntax.Abstract         as A
import           Agda.Syntax.Common
import qualified Agda.Syntax.Internal         as I
import           Agda.Syntax.Position
import           Agda.TheTypeChecker
import           Agda.TypeChecking.Errors
import           Agda.TypeChecking.Monad
import           Agda.Utils.FileName
import           Agda.Utils.Monad             hiding (ifM)

import qualified Control.Exception            as E
import           Control.Lens
import           Control.Monad
import           Control.Monad.Except
import           Control.Monad.Reader
import           Control.Monad.State.Strict
import           Control.Monad.Trans.Maybe
import           Data.Generics.Geniplate
import qualified Data.List                    as List
import           Text.Printf

import qualified Martin.Agda.MakeCaseModified as MC
import qualified Martin.Agda.Util             as AU
import qualified Martin.Agda.Lens             as AL
import qualified Martin.Auto.ProofSearch      as P
import           Martin.Auto.SearchTree
import           Martin.Auto.Translation

-- | A strategy describing how to solve a clause towards an auto-generated model solution
data ClauseStrategy
  = SplitStrategy String [ClauseStrategy]
  -- ^ @Split v next@ splits on variable @v@ in the current holes, and applies the strategies
  -- in @next@ to the corresponding new clause. An empty list of subordinate clauses indicates
  -- that the split introduced an absurd-pattern.
  | RefineStrategy P.Proof
  -- ^ refines the current hole with a proof found by the proof search
  deriving (Show, Read, Eq, Ord)

-- | A strategy for solving an exercise consists of one strategy for each clause of the exercise
type ExerciseStrategy = [Maybe ClauseStrategy]

prettyStrategy :: ClauseStrategy -> String
prettyStrategy (SplitStrategy s cl) = unlines
    (("split at " ++ s ++ " and") :
     zipWith (printf "    %d. %s") [1 :: Int ..] (map prettyStrategy cl))
prettyStrategy (RefineStrategy pr) =
    "refine with: " ++ P.proofToStr pr

-- | Pairs an abstract Agda program with the type checker state after checking said program.
data StatefulProgram = StatefulProgram
  { _programDecls   :: [A.Declaration]
  , _programTCState :: TCState
  -- ^ the state of the type checker after checking the program.
  -- In particular, all interaction points are registered and paired with the corresponding meta variables.
  }
makeLenses ''StatefulProgram

data SearchEnvironment = SearchEnvironment
  { _initialTCState  :: TCState
  -- ^ the initial state just after loading the Agda primitives.
  -- No user bindings have been checked yet.
  , _initialTCEnv    :: TCEnv
  -- ^ the default type checker environment
  , _splitDepthLimit :: Int
  -- ^ Constructor depth of a variable in a pattern for it to be eligible for splitting on
  , _proofDepthLimit :: Int
  -- ^ maximum depth for terms generated by proof search
  , _debugMode       :: Bool
  -- ^ enables debugging features
  }
makeLenses ''SearchEnvironment

type Search = MaybeT (ReaderT SearchEnvironment IO)

debugPrint :: (Show a) => a -> Search ()
debugPrint = whenDebug . liftIO . print

whenDebug :: Search () -> Search ()
whenDebug act = view debugMode >>= \dbg -> when dbg act

-- | Apply a proof search strategy,
-- if not possible select a variable and split.
proofSearchStrategy :: StatefulProgram
                    -> InteractionId
                    -> Search ClauseStrategy
proofSearchStrategy prog ii = do
  debugPrint ("proofSearchStrategy " ++ show ii)
  -- First we check whether the meta is in a top level rhs.
  ((goal, hdb),_) <- runTCMSearch (view programTCState prog) $ goalAndRules ii
  whenDebug $ liftIO $ putStrLn $ unlines $
      [ "goal: " ++ show goal
      , "hints: " ] ++ map show hdb
  depth <- view proofDepthLimit
  let prfs = iddfs $ cutoff depth $ P.solve goal hdb
  mplus (RefineStrategy <$> msum (map (trySolution prog ii) prfs))
        (do guard (AU.checkTopLevel ii (view programDecls prog))
            splitStrategy prog ii)

-- | Select a variable in the scope of an Interation id
-- to split.
selectVarsToSplit :: StatefulProgram
                 -> InteractionId
                 -> Search [String]
selectVarsToSplit prog ii = do
  (vars, _) <- view splitDepthLimit >>= runTCMSearch (view programTCState prog) . f
  return vars
    where
      f lim = do
        m <- lookupInteractionId ii
        -- Find the clause that contains this goal
        (_,_,cl) <- MC.findClause m
            -- From the clause we get all patterns
        let dBrPats = deBruijnPats cl
            -- List of all found variables with their constructor depth
            allVarDepths = concatMap varDepths dBrPats
            -- Only tuples whose constructor depth was at most the given limit
            varDepthsLim = filter (\(n, _) -> n <= lim) allVarDepths
            -- sorted by constructor depth from lowest to highest
            sortedVarDepths = List.sort varDepthsLim
        -- Find all local variables in scope
        localVars <- AU.varsInScope ii
        -- Only visible local variables can be split on
        return $ List.intersect (map snd sortedVarDepths) (map show localVars)


deBruijnPats :: I.Clause -> [I.DeBruijnPattern]
deBruijnPats cl = map namedArg $ I.namedClausePats cl

-- 1. Removes the order indice in the DeBruijnPattern.
-- 2. Finds all variables in the pattern and assigns it a constructor depth of 0
-- 3. For every cons that we pass through we increment the constructor depth
-- 4. Returns a list of tuple of a variable and its constructor depth
varDepths :: I.DeBruijnPattern -> [(Int, String)]
varDepths dBrPat = varLevel' (fmap snd dBrPat)
  where
    varLevel' (I.VarP x)
    -- We can't split on an underscore
      | x /= "_"              = [(0, x)]
      | otherwise             = []
    varLevel' (I.ConP _ _ xs) = map (\(n,x) -> (n + 1, x)) $ concatMap (varLevel' . namedArg) xs
    varLevel' _               = []


-- | Try a Proof to see if it typechecks termination checker.
-- A known problem with this function is if the we feed the hole
-- with a non structurally smaller expression then it just loops.
-- This bug also happens in Agda #2286
trySolution :: StatefulProgram
            -> InteractionId
            -> P.Proof -> Search P.Proof
trySolution prog ii proof = do
  debugPrint ("trying solution: " ++ P.proofToStr proof)
  -- Save the old TCM state because proofToAbstractExpr may change it.
  (expr, _) <- runTCMSearch (view programTCState prog) $ B.parseExprIn ii noRange (P.proofToStr proof)
  -- Replace the hole in the old program with the new expression.
  let newProg = views programDecls (AU.replaceHole ii expr) prog
  -- Try to typecheck the new program.
  proof <$ runTCMSearchFresh (checkProgram newProg)

-- | Try splitting on variables given in an InteractionId
splitStrategy :: StatefulProgram
              -> InteractionId
              -> Search ClauseStrategy
splitStrategy prog ii = do
  vars <- selectVarsToSplit prog ii
  msum $ map (splitSingleVarStrategy prog ii) vars

-- | Split a given variable in an InteractionId
splitSingleVarStrategy :: StatefulProgram -> InteractionId -> String -> Search ClauseStrategy
splitSingleVarStrategy prog ii var = do
  debugPrint ("splitting on var: " ++ var)
  ((_, newClauses),_) <- runTCMSearch (view programTCState prog) $ MC.makeCase ii noRange var
  debugPrint ("new clauses: " ++ show newClauses)
  ((newProg, oldMetas),_) <- runTCMSearchFresh $
    checkProgram (views programDecls (AU.replaceClauses ii newClauses) prog)
  let newMetas = toListOf (programDecls . traverse . AL.questionMarks . _2 . filtered (`notElem` oldMetas)) newProg
  SplitStrategy var <$> mapM (proofSearchStrategy newProg) newMetas

-- | Runs a TCM computation in our Search Monad starting with some state.
--   Errors are converted to mzero.
runTCMSearch :: TCState -> TCM a -> Search (a, TCState)
runTCMSearch tcs tcm = do
  tce <- view initialTCEnv
  r <- liftIO $ (Right <$> runTCM tce tcs tcm) `E.catch` (\(e :: TCErr) -> return $ Left e)
  case r of
    Left e  -> do
      debugPrint e
      mzero
    Right v -> return v

-- | Runs a TCM computation inside our Search Monad using the initial state from the environment.
runTCMSearchFresh :: TCM a -> Search (a, TCState)
runTCMSearchFresh tcm = view initialTCState >>= flip runTCMSearch tcm

-- | Runs a TCM computation in an arbitrary Monad supporting IO and errors.
--   At the boundary, TCM exceptions are prettified and passed upwards as a string.
runTCMError :: (MonadError String m, MonadIO m) => TCEnv -> TCState -> TCM a -> m (a, TCState)
runTCMError tce tcs tcm = do
  (r, tcs') <- liftIO $ runTCM tce tcs $ (Right <$> tcm) `catchError` (\(e :: TCErr) -> Left <$> prettyError e)
  case r of
    Left e  -> throwError e
    Right v -> return (v, tcs')

-- | Generate a Strategy given a list of Declaration.
-- This is the top level function.
generateStrategy :: [A.Declaration] -> Search ExerciseStrategy
generateStrategy prog = prepareState prog contFail contSuccess where
  contFail _ = mzero
  contSuccess sprog = do
    let metas = toListOf (programDecls . traverse . AL.questionMarks . _2) sprog
    debugPrint ("Generate strategy for metas: " ++ show metas)
    mapM (lift . runMaybeT . proofSearchStrategy sprog) metas

-- | Applies a strategy to solve a given program. Guarantees that the resulting program type-checks.
applyStrategy' :: [A.Declaration] -> ExerciseStrategy -> ExceptT String (ReaderT SearchEnvironment IO) [A.Declaration]
applyStrategy' decls strat = view programDecls <$> prepareState decls throwError (go 0 strat) where
  go _ [] prog = return prog
  -- if the strategy doesn't know how to solve a hole, skip it.
  -- The 'skip' argument keeps track of how many holes have been skipped so far, to correctly compute interaction ids
  go skip (Nothing : rest) prog = go (skip + 1) rest prog
  go skip (Just st : rest) prog = do
    tce <- view initialTCEnv
    itcs <- view initialTCState
    let ii = InteractionId skip
    case st of
      SplitStrategy var cs -> do
        ((_, newClauses),_) <- runTCMError tce (view programTCState prog) $ MC.makeCase ii noRange var
        ((sprog, _),_) <- runTCMError tce itcs $ checkProgram (AU.replaceClauses ii newClauses $ view programDecls prog)
        go skip (map Just cs ++ rest) sprog
      RefineStrategy prf -> do
        (expr, _) <- runTCMError tce (view programTCState prog) $ B.parseExprIn ii noRange (P.proofToStr prf)
        ((sprog, _),_) <- runTCMError tce itcs $ checkProgram (AU.replaceHole ii expr $ view programDecls prog)
        go skip rest sprog

-- | Initially prepares the Agda state by type checking the given program
--   and processing all import statements.
prepareState :: (MonadReader SearchEnvironment m, MonadIO m)
             => [A.Declaration] -- ^ the initial, unchecked program
             -> (String -> m a) -- ^ a failure continuation
             -> (StatefulProgram -> m a)
                -- ^ a success continuation receiving a checked program and
                -- a modified initial state in the environment containing imported declarations
             -> m a
prepareState prog contFail contSuccess = do
  tce <- view initialTCEnv
  tcs <- view initialTCState
  ret <- runExceptT $ runTCMError tce tcs $ do
    AU.importAllAbstract prog
    imported <- get -- get a snapshot of the state after importing our stuff
    (sprog, _) <- checkProgram prog
    return (sprog, imported)
  case ret of
    Left e -> contFail e
    Right ((sprog, impState), _) ->
      -- use the import snapshot as the new original state
      local (initialTCState .~ impState) $ contSuccess sprog

-- | Checks the declarations and returns a program associated with the type-checked TCState
--   and a list of the old interaction points.
checkProgram :: [A.Declaration] -> TCM (StatefulProgram, [InteractionId])
checkProgram decls = do
  (interactionDecls, oldMetas) <- AU.rebuildInteractionPoints decls
  checkDecls interactionDecls
  unfreezeMetas
  sprog <- StatefulProgram interactionDecls <$> get
  return (sprog,oldMetas)

-- | A session encapsulates some state and provides a high level interface for interacting with Agda.
data Session = Session
  { buildStrategy :: [A.Declaration] -> IO (Maybe ExerciseStrategy)
    -- ^ Builds a strategy for the given program.
  , applyStrategy :: [A.Declaration] -> ExerciseStrategy -> IO (Either String [A.Declaration])
    -- ^ Applies a strategy to solve a program. Guarantees that the resulting program type-checks.
  }

-- | Initializes an Agda session working on a file.
initSession :: AU.AgdaOptions -> AbsolutePath -> IO Session
initSession opts path = do
  (tcmState,_) <- runTCM initEnv initState $ AU.initAgda opts
  let env = SearchEnvironment
        { _initialTCState  = tcmState
        , _initialTCEnv    = initEnv { envCurrentPath = Just path }
        , _splitDepthLimit = 4
        , _proofDepthLimit = 7
        , _debugMode       = False
        }
  return Session
     { buildStrategy = \decls -> runReaderT (runMaybeT $ generateStrategy decls) env
     , applyStrategy = \decls strat -> runReaderT (runExceptT $ applyStrategy' decls strat) env }


